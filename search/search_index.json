{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CC2 - Proyecto Final - Mail Client/Server Proyecto: Mail Client/Server Tema : POO y Estructuras de Datos Fecha de Entrega : Jueves 21 de noviembre del 2019 (antes de las 9 AM si es secci\u00f3n A, B, C o D; antes de las 6pm si es secci\u00f3n AN) Grupo : Cuatro, el cual se dividir\u00e1 en dos subgrupos de dos personas Correcci\u00f3n personal : 21 de noviembre del 2019 despu\u00e9s hora de entrega Este es el proyecto final del curso, por lo que se espera que usted ponga mucho esfuerzo en hacerlo, para demostrar los conocimientos que adquiri\u00f3 durante todo el semestre. El prop\u00f3sito del proyecto es que usted aplique todos los conceptos aprendidos y desarrolle un software completo utilizando como herramienta el lenguaje de programaci\u00f3n Java. Ademas de implementar lo que se le pida, debe cumplir con las siguientes especificaciones para que su proyecto sea considerado como valido: El lenguaje de programaci\u00f3n a utilizar para la implementaci\u00f3n debe ser Java. Por el tipo de proyecto DEBE implementar una interfaz gr\u00e1fica. Para este proyecto se le pide que utilice JFrames, NO APPLETS. Debe utilizar la o las estructuras de datos vistas en clase que mas le ayuden a guardar los datos requeridos. DEBE de utilizar las clases prove\u00eddas por Java para esto. Para la conservaci\u00f3n de los datos ingresados durante la ejecuci\u00f3n del programa, usted tiene que utilizar una base de datos , de tal forma que cuando se vuelva a ejecutar ya utilice datos guardados en ella. Se le explicara mas adelante como la debe utilizar. Su comunicaci\u00f3n debe ser cliente-servidor-cliente , no puede ser solo cliente-cliente . En este proyecto consiste en implementar una aplicaci\u00f3n (cliente-servidor) para un servicio de E-mail. Su proyecto, en general, debe permitir a un usuario, mandar emails a contactos que pertenezcan al mismo servidor, y a contactos en otros servidores. La aplicaci\u00f3n estar\u00e1 dividida en un programa cliente, y un programa servidor, los cuales se comunicaran entre si, utilizando un protocolo de comunicaci\u00f3n definido por nosotros. Dicha comunicaci\u00f3n, solo sera permitida entre cliente y servidor, y/o servidor y servidor. 1. Programa Cliente El programa cliente es el encargado de brindar una interfaz al usuario, en la cual pueda hacer las siguientes tareas: Manejo de Contactos: El usuario debe ser capaz de ingresar contactos nuevos (para hacerlo mas simple, solo se guarda el email de el contacto), y ver la lista de contactos que tiene. Lectura de emails: El usuario debe ser capaz de poder leer los emails que le han enviado. Tanto los emails nuevos, como los ya leidos anteriormente. Envi\u00f3 de emails: El usuario debe ser capaz de enviar emails a cualquiera de sus contactos. El email puede tener uno o mas recipientes (to recipients). 2. Programa Servidor El programa servidor es el encargado de proveer el servicio de envi\u00f3 de emails, entre usuarios del mismo servidor, y desde/hacia usuarios de otros servidores. Dado que es una aplicaci\u00f3n cliente-servidor, para que un programa cliente envi\u00e9 un email, lo debe hacer a trav\u00e9s de el servidor (solicit\u00e1ndole al servidor que envi\u00e9 el email al respectivo contacto), el cual se comunicara con el programa cliente o servidor respectivo y enviara la informaci\u00f3n. Cada grupo tendr\u00e1 que implementar un programa cliente, y un programa servidor para esta aplicaci\u00f3n. Los grupos se dividir\u00e1n en dos subgrupos, un subgrupo se encargara de hacer el cliente, y otro subgrupo se encargara de hacer el servidor. Uno de los objetivos de el proyecto, es que cualquier cliente perteneciente a cualquier servidor debe poder interactuar (mandar emails) hacia cualquier otro cliente perteneciente a cualquier otro servidor. Para esto, definimos un protocolo de comunicaci\u00f3n, tanto para el programa cliente, como para el programa servidor. 3. Especificaciones y Protocolo de comunicaci\u00f3n A continuaci\u00f3n se describe el protocolo completo de comunicaci\u00f3n de un cliente y un servidor. Aseg\u00farese de seguirlo al pie de la letra para que pueda comunicarse sin problema con cualquier otro servidor o cliente. Dentro de la definici\u00f3n de el protocolo, tambi\u00e9n se le dan especificaciones de la funcionalidad que se requiere en el proyecto. 3.1 CLIENTE La comunicaci\u00f3n entre cliente y servidor se har\u00e1 a base de comandos escritos en hileras de caracteres. Dado que su servidor o cliente debe poder comunicarse con el servidor o cliente de otro grupo, deben asegurarse de mandar por la red Strings, y no otro tipo de dato. Los comandos del cliente al servidor son descritos en esta parte. Puede que describamos algunos comandos de respuesta del servidor, asi que este atento a tomar nota. 3.1.1 Login La primera tarea que debe dejar hacer el programa cliente a la hora de ejecutarse es permitir al usuario hacer login al servidor. El cliente debe leer del usuario el username, el nombre del servidor al que se va a comunicar y su password (tome en cuenta que el password no puede ser visto por el usuario). El usuario y servidor deben ser ingresados por el usuario de la siguiente manera: 1 usuario@servidor El cliente debe separar este String en dos cosas: el usuario y el nombre del servidor. Despu\u00e9s de verificar que el servidor ingresado este en su tabla de IPs de servidores, el cliente debe abrir una conexi\u00f3n hacia ese servidor especifico y mandarle la primera instrucci\u00f3n que seria la de login: 1 LOGIN username password Al recibir este comando, el servidor debe realizar una serie de operaciones: Primero debe verificar que el usuario (username) se encuentre en su tabla de usuarios. Si no se encuentra, el server debe responder con un error. (lo explicaremos mas tarde) Ya que se verifico que el usuario exista, se compara el password. Si el password es valido entonces se manda al cliente el siguiente acknowledge: 1 OK LOGIN para hacerle ver al cliente que ese usuario existe y que su login esta autorizado, y se marca al usuario como \"Logged In\" Si el password es no valido, el server debe responder con un error (los explicaremos en la parte de errores de el server) Despu\u00e9s de recibir el OK LOGIN del servidor, el cliente debe solicitar la lista de contactos del usuario (la cual esta guardada en el servidor) con la instrucci\u00f3n: 1 CLIST username El server debe responder con una o varias instrucciones, ya que es una lista de uno o varios contactos. Cuando se manda un contact que NO es el ultimo en la lista el server manda una instrucci\u00f3n de la forma : 1 OK CLIST contact@server donde contact es el username del contact, y server el server al que pertenece el contact. Si el contact es el ultimo en la lista, entonces la instrucci\u00f3n seria: 1 OK CLIST contact@server * con el \"*\" el cliente sabr\u00eda que ahi se termino toda la contact list. Luego de obtener el contact list, se deben solicitar los emails nuevos, si hay alguno. Esto se hace con la instrucci\u00f3n: 1 GETNEWMAILS username El server responder\u00e1 a este comando, con la lista de emails nuevos, o una instrucci\u00f3n que indique que no existen emails. Si existen emails, el servidor responder\u00e1 con una instrucci\u00f3n de esta forma: 1 OK GETNEWMAILS sender subject body en donde sender es el email de el contacto o usuario que mando el email, subject es el titulo del email, y body es el cuerpo del email, el texto asociado al email. Dado que pueden haber mas de un nuevo email, para indicar que el email es el ultimo en la lista, se le agrega un \"*\" al final de la instrucci\u00f3n. 1 OK GETNEWMAILS sender subject body * En el caso de que no hayan emails nuevos, el servidor responder\u00e1 con la instrucci\u00f3n: 1 OK GETNEWMAILS NOMAILS Algo importante, es que la fase de login, no es el \u00fanico momento en el que GETNEWMAILS debe ser utilizado. Cada vez que el cliente quiera \"refrescar\" su lista de emails nuevos, debe hacer esta solicitud, el servidor no manda los emails al cliente autom\u00e1ticamente a la hora de recibirlos, es el cliente el que tiene que hacer esto. Ya que el cliente obtuvo el contact list del usuario y sus emails nuevos, se termina el proceso de login del cliente. 1 2 3 4 5 6 7 8 9 10 EJEMPLO DE LOGIN SESSION SIN ERRORES Client : LOGIN andrea password Server : OK LOGIN Client : CLIST andrea Server : OK CLIST contact1@server1 Server : OK CLIST contact2@server2 Server : OK CLIST contact3@server3 * Client : GETNEWMAILS andrea Server : OK GETNEWMAILS xxx@server1 Hola Hola, como estas? Nos vemos pronto Server : OK GETNEWMAILS yyy@server2 Cumple Sofia Hola a todos, el cumple de Sofia va a ser en su casa, el sabado a las 8, los veo ahi. * 3.1.2 Envi\u00f3 de Emails Para mandar un email a alg\u00fan contacto, el cliente debe mandar la informaci\u00f3n de el email al servidor, el cual despu\u00e9s se encargara de mandarlo al contacto o server indicado. Las instrucciones que debe mandar el cliente al servidor son las siguientes (todas tienen que ir seguidas, sin ninguna otra instrucci\u00f3n en medio): Primero, el cliente debe avisar que a continuaci\u00f3n va a mandar datos de un email, con la siguiente instrucci\u00f3n: 1 SEND MAIL Luego, siguiente a esa instrucci\u00f3n (sin esperar respuesta), se manda el recipient o recipients del email, con las instrucciones: 1 2 MAIL TO contact@server MAIL TO contact@server * el \"*\" indica que ese es el ultimo recipient, o si solo hay uno, ese es el \u00fanico. Despu\u00e9s, deben mandarse las instrucciones de los dem\u00e1s datos de el email (subject y body): 1 2 MAIL SUBJECT text MAIL BODY text y por ultimo, se indica que ya se termino de mandar los datos de el email, con la instrucci\u00f3n: 1 END SEND MAIL a lo que el servidor debe contestar con un: 1 OK SEND MAIL si no hay problemas con los datos. Si en dado caso hay alg\u00fan problema o error, el server responder\u00e1 con un mensaje de error (discutiremos esto en la parte de errores del server). 3.1.3 Nuevos Contactos Para agregar un nuevo contacto, el usuario debe ingresar el contacto de la forma contact@server. El cliente antes de poderlo agregar debe verificar su existencia entonces debe mandar la siguiente instrucci\u00f3n al servidor: 1 NEWCONT contact@server el servidor, despu\u00e9s de verificar que SI existe el contacto, responde al cliente con la instrucci\u00f3n: 1 OK NEWCONT contact@server Si en dado caso, el contacto no existe, el server devolver\u00e1 una instrucci\u00f3n de error (se mostraran las instrucciones de error cuando se est\u00e9n describiendo las instrucciones de el server). 3.1.4 NOOP y LOGOUT Cuando el usuario se va a hacer logout del cliente, el cliente debe mandar un aviso al servidor para que el servidor cierre la sesi\u00f3n con ese cliente, y actualice el estado del usuario a offline: 1 LOGOUT Para que el cliente pueda cerrar la sesi\u00f3n, el servidor debe mandarle un mensaje: 1 OK LOGOUT y recibido este mensaje, el cliente puede cerrar la sesi\u00f3n. Si no lo recibo NO puede cerrar la sesi\u00f3n. El NOOP es un shortcut para NOOPERATION . Esta instrucci\u00f3n sirve para que el servidor sepa que el cliente todav\u00eda esta vivo, es decir que el cliente todav\u00eda esta conectado. Si el servidor no recibe este NOOP cada cierto tiempo (que pasa sin que el cliente haga nada) entonces el servidor cierra la conexi\u00f3n, ya que no esta seguro que el cliente siga vivo. Esto es para evitar que el servidor mantenga conexiones abiertas que no son utilizadas porque el cliente muri\u00f3 (se desconecto). Cuando hablo de que el cliente muri\u00f3 es por ejemplo que la computadora por alguna raz\u00f3n se apago, y no dio tiempo de hacer un LOGOUT formal, entonces el cliente ya no existe, y el servidor tiene abierta esa conexi\u00f3n todav\u00eda, en vano. Entonces, para evitar esto el NOOP se debe mandar cada 20 segundos (20000 milisegundos) despu\u00e9s del ultimo comando. Cada comando que se mande o se reciba (sea cual sea) inicializa el contador del tiempo, y cuando el tiempo llegue a 20000 entonces se manda un noop: 1 NOOP el cual debe seguir con la respuesta del servidor: 1 OK NOOP para que el cliente tambi\u00e9n sepa que el servidor esta vivo. 3.2 SERVIDOR Usualmente, el servidor responde a las peticiones del cliente o de otro servidor. En esta parte le explicaremos como debe actuar el servidor con respecto a cada comando recibido ya sea del cliente o de otro servidor. 3.2.1 CLIENTE - SERVIDOR 3.2.1.1 Login 1 LOGIN username password Este comando es mandado por el cliente para hacer un login de un usuario especifico. Dentro de el servidor existe una tabla de usuarios existentes con su password, y el estado en el que se encuentran (online/offline). Lo primero que debe hacer el servidor es buscar si el usuario existe. Si no existe debe mandar al cliente el comando de error: 1 LOGIN ERROR 101 donde 101 representa al tipo de error \"unknown user\". Si el usuario si existe, entonces compara el password que se guardo en la tabla con el recibido en el comando. Si el password NO es igual entonces el servidor manda al cliente el comando de error: 1 LOGIN ERROR 102 donde 102 representa al tipo de error \"invalid password\". Si el password es correcto, entonces el servidor debe cambiar el estado del usuario a online y mandar al cliente la respuesta: 1 OK LOGIN que significa que el usuario ya esta ingresado como online. 3.2.1.2 Contact List 1 CLIST username Este es el comando de solicitud de contact list por un cliente. Al recibir el servidor el request de una contact list, debe buscar los contacts asociados con ese usuario y sus estados. Si no hay ningun contact asociado con el usuario el servidor debe mandar un comando de error: 1 CLIST ERROR 103 donde 103 corresponde a \"no contacts found\" . N\u00f3tese que este no es un error como tal, es un warning. Nosotros trabajaremos errores y warnings de igual manera. Si existe alg\u00fan contact entonces el servidor debe mandar los siguientes comandos: 1 2 OK CLIST contact@server o OK CLIST contact@server * donde contact es el username del contacto, y server es el servidor al que pertenece el contact. El \"*\" quiere decir que ese contacto es el ultimo en la lista. 3.2.1.3 Send Mail 1 SEND MAIL Esta es el comando que manda el cliente cuando quiere avisarle al servidor que esta por mandar informaci\u00f3n de un email. El servidor debe esperar a recibir el 1 END SEND MAIL para analizar la informaci\u00f3n de email que el cliente mando. Una de las cosas que el servidor debe hacer, es verificar que el o los recipients existan. Si el contacto es de el mismo servidor, esto lo har\u00eda chequeando la tabla de usuarios, si el contacto es de otro servidor, tiene que preguntar a ese servidor si ese contacto existe (esto lo discutiremos en las conversaciones servidor-servidor). Si el contacto no existe, entonces debe mandar al cliente el siguiente error: 1 SEND ERROR 104 contact@server en donde 104 es el error que indica \"unknown contact\" . Si el servidor no existe (o no se encuentra online), entonces se manda al cliente la instrucci\u00f3n: 1 SEND ERROR 105 contact@server en donde 105 indica un error de \"unknown server\" . Ademas de esto, el server debe chequear que los datos que se mandaron est\u00e9n completos, si no es asi, mandar al cliente una de estas tres instrucciones de error: 1 2 3 SEND ERROR 106 SEND ERROR 107 SEND ERROR 108 en donde 106 indica un error de \"no recipient(s)\" , 107 un error de \"no subject\" y 108 un error de \"no body\" . 3.2.1.4 Nuevo Contacto 1 NEWCONT contact@server Este es el comando del cliente que nos indica que su usuario quiere agregar un nuevo contacto. Antes de agregar un nuevo contact el servidor debe asegurarse que el contact realmente exista. Si el contact es local, debe buscarlo en su tabla de usuarios, si no lo encuentra, entonces mandara un mensaje de error: 1 NEWCONT ERROR 109 contact@server que corresponde al tipo de error \"contact not found\". Si el contact no es local, entonces hay que verificar con el servidor correspondiente. Si el server no existe o no esta online, hay que mandar al cliente el mensaje de error: 1 NEWCONT ERROR 110 contact@server que corresponde al tipo de error \"server not found\". Si el contacto existe, entonces se debe mandar un mensaje al cliente : 1 OK NEWCONT contact@server 3.2.1.5 NOOP 1 NOOP NOOP es la instruccion de NO OPERATION solo para que el servidor sepa que el cliente todavia esta vivo. Al recibirla, el servidor debe reiniciar el contador del tiempo del cliente, y mandar una instruccion: 1 OK NOOP para avizarle a el cliente que recibio su mensaje, y para que el sepa que el servidor todavia esta vivo tambien. 3.2.2 SERVIDOR - SERVIDOR El servidor no solo debe comunicarse con los clientes, sino tambi\u00e9n con otros servidores para hacer posible el envi\u00f3 de emails entre usuarios que pertenecen a diferentes servidores. Mas adelante hablaremos de como sabe el server que servidor existen y cuales son sus ips, por el momento supondremos que el servidor ya tiene una tabla con los ips y nombres de los servidores que estan online en este momento. La comunicaci\u00f3n entre servidor y servidor, se reduce a envi\u00f3 de emails y chequeo de contactos existentes. 3.2.2.1 Send Mail 1 SEND MAIL contact@server Este comando es enviado de un servidor al otro para indicar que va a mandar informaci\u00f3n acerca de un email que se necesita ser enviado al contacto que se indica en el mismo. Despu\u00e9s a esto, el servidor que mando el comando, debe proseguir a enviar los datos de el email (sin esperar respuesta), de la siguiente forma: 1 2 3 MAIL FROM username@server MAIL SUBJECT text MAIL BODY text y despues concluir con el comando: 1 END SEND MAIL Si no hay problema con el email, entonces el servidor debe contestar con un 1 OK SEND MAIL En el caso de que el contacto no exista, el servidor debe enviar el mensaje de error: 1 SEND ERROR 201 contact@server el cual representa el tipo de error \"unknown contact\". En el caso de otros errores, el servidor debe mandar una de estas posibles instrucciones de error. 1 2 3 SEND ERROR 202 SEND ERROR 203 SEND ERROR 204 En donde 202 es el tipo de error \"no sender (from)\", 203 es \"no subject\" y 204 es \"no body\". El servidor que recibi\u00f3 la notificaci\u00f3n de envi\u00f3 de email, debe guardar el email en la base de datos, el cual sera mandado al usuario en el momento en el que el cliente lo solicite. 3.2.2.2 Check Contact 1 CHECK CONTACT contact@server Si el contacto no existe entonces mandar el warning: 1 CHECK ERROR 205 el cual representa el tipo de error \"unknown contact\" , y si el server que aparece en \"contact@server\" de la instrucci\u00f3n, no es este server, entonces se debe mandar el error: 1 CHECK ERROR 206 el cual representa el tipo de error \"not this server\" . 3.2.3 SERVIDOR - DNS Para que esta aplicaci\u00f3n funcione correctamente , y los servidores puedan conectarse entre si, va existir un programa (hecho por nosotros, no por ustedes) que va a tener la tarea de un DNS. Este programa llevara el registro de los servidores que est\u00e9n \"online\" y sus ips, para que los servidores puedan solicitarla cuando lo necesiten. Para llevar la tabla actualizada, se necesita que cuando el servidor empiece a ejecutarse, mande un mensaje al programa DNS (cuyo ip debe poderse ingresar en el programa servidor), avis\u00e1ndole que ahora esta en linea, y registrando su ip. La instrucci\u00f3n para esto es: 1 ONLINE servername ip a lo que el DNS le contestara un 1 OK ONLINE servername Si el servidor que manda esta instrucci\u00f3n, ya existe en la tabla de el DNS, entonces se modificara el ip en la tabla (si el ip que se mando en la instrucci\u00f3n, es diferente al que estaba en la tabla). A la hora de que el servidor se \"apague\", debe mandar al DNS la instrucci\u00f3n 1 OFFLINE servername a lo que el DNS contestara 1 OK OFFLINE servername Para obtener el ip-table de los servidores en cualquier momento, el server debe mandar al DNS una solicitud, con la instrucci\u00f3n: 1 GETIPTABLE a lo que el DNS contestara con un listado de servidores con sus ips, utilizando 1 2 OK IPTABLE servername ip o OK IPTABLE servername ip * en donde el \"*\" significa que ese server es el ultimo en la lista/tabla Los errores que manejara(devolver\u00e1) el DNS son: 1 ONLINE ERROR 301 Error que indica un \"ip invalido\". 1 OFFLINE ERROR 302 Error que indica que el servidor que esta haciendo offline, no existe en la tabla (ya sea nunca hizo un online, o ya hab\u00eda hecho offline antes). 1 GETIPTABLE ERROR 303 Que representa un warning de que no hay servidores en la tabla. 4 Otras Indicaciones 4.1 Invalid Command El error que cualquiera de los programas envi\u00e1, si la instrucci\u00f3n que se le envi\u00f3 es invalida, debe ser: 1 INVALID COMMAND ERROR 4.2 Puertos El servidor debe escuchar en dos puertos diferentes, en el puerto 1400 para los clientes, y en el puerto 1500 para los servidores. El cliente siempre escuchara en el puerto 1400 . El DNS escuchara en el puerto 1200 . 4.3 Funciones del Servidor El servidor tiene como funci\u00f3n principal esperar solicitudes de clientes y servidores. Sin embargo, tambi\u00e9n debe tener funciones para el usuario que lo esta corriendo (server administrator). Una de las funciones que debe permitir el servidor es ingresar el ip de DNS, el cual se mantendr\u00e1 mientras el servidor este ejecut\u00e1ndose. SOLO se pueden agregar usuarios al servidor por medio del mismo servidor, no por medio de clientes, por lo que debe tener esta opci\u00f3n. Tambi\u00e9n debe tener la funci\u00f3n de poder cambiar los puertos en donde se escucha. 4.4 Log de Comandos Tanto el servidor como el cliente tiene que escribir los comandos que manda y escucha en la consola. 4.5 Interfaz Grafica Tanto el programa cliente, como el programa servidor deben tener interfaz gr\u00e1fica. 4.6 Base de Datos Dado que el servidor debe mantener datos como: usuarios, emails, tabla de servidores, etc, usted DEBE de utilizar una base de datos para guardar estos. De tal forma que cuando el servidor se ejecute, lea los datos de dicha base de datos. El cliente deber\u00eda utilizar esta base de datos para guardar los emails (ya leidos de el servidor) por usuarios. La base de datos que usted puede utilizar es SQLite ( http://www.sqlite.org/ ). Para el manejo de la base de datos se le provee la clase DB, la cual puede encontrar en este paquete . Este paquete contiene: La clase DB, en el archivo DB.class El Javadoc para esta clase (API) Una clase y una base de datos prueba. Para poder utilizar la clase, revise el API y la clase de prueba. Si usted desea utilizar otra base de datos, puede hacerlo, utilizando otra librer\u00eda que le ayude a manejar lo puede hacer 5. Puntos extra Los puntos extra los dejo a su criterio. Nosotros decidiremos si su trabajo extra merece puntos o no, asi que sea creativo. 6. Entrega Su proyecto es entregado por medio del GES y usted solo debe entregar un archivo llamado pj3-grupoN.zip (donde N es el numero de grupo que se les asigno). Dentro de ese archivo .zip deben ir todos los documentos y archivos que se le piden a continuaci\u00f3n, incluyendo los archivos/documentos extra que usted utilizo para la implementaci\u00f3n de su proyecto. La entrega del proyecto sera personal, el dia que se les indico deben presentarse en la Universidad todos los integrantes del grupo, y traer lo siguiente: Su proyecto, es decir, todos los archivos .java que utilizo en el mismo. Debe venir preparado para mostrar el funcionamiento del mismo en red. (Computadoras, cables de red, etc) Cada uno de los procedimientos y funciones de su c\u00f3digo deben estar debidamente comentariados. Asi como cada clase. (esto no quiere decir que excesivamente comentariadas) Un documento impreso en donde explique como implemento su proyecto, herramientas que utilizo, y todas las estructuras de datos que utilizo, en donde y para que. Un manual de usuario en donde indicara como utilizar su cliente y su servidor. 7. Grupos Para recibir numero de grupo debe mandar un email a al correo de su profesor de curso copiando a su auxiliar de clase, indicando los nombres de sus integrantes, de que secci\u00f3n son, e indicando tambi\u00e9n quienes son los encargados del cliente, y quienes del servidor, esto lo debe hacer a m\u00e1s tardar el 25 de octubre del 2019. 8. \u00bfComo empezar? Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin. Si tienen alguna pregunta pueden dir\u00edjanse a Slack y preguntar en los canales correspondientes, solamente si ya han le\u00eddo completamente este documento. Tienen que utilizar git y GitHub para este proyecto, ustedes pueden encontrar un tutorial bastante bueno en el siguiente link . Cada vez que hagan un avance significativo en su proyecto por favor realicen un commit y realicen un push hacia GitHub. Para comenzar con el proyecto, primero tienen que crear su repositorio, esto lo realizan aqu\u00ed . Tienen que trabajar en grupos de 4 personas, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, deben haber enviado un correo a su catedratico con copia a su auxiliar de clase (recuerde incluir en el asunto del correo CC2 y su secci\u00f3n) para que se les asigne un n\u00famero de grupo N el cual les servira para ingresar el nombre grupo con el formato grupo-N , por ejemplo si su n\u00famero de grupo 2B deberia ingresar grupo-2B . En esta ocasi\u00f3n no se les brindan archivos base por lo que el repositorio estara vacio, debe agregar un archivo README.md donde debe colocar los integrantes de su grupo indicando quienes trabajaran en el cliente y quienes trabajaran en el server. Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO y obtendr\u00e1 una nota de 0.","title":"Proyecto Final"},{"location":"#cc2-proyecto-final-mail-clientserver","text":"Proyecto: Mail Client/Server Tema : POO y Estructuras de Datos Fecha de Entrega : Jueves 21 de noviembre del 2019 (antes de las 9 AM si es secci\u00f3n A, B, C o D; antes de las 6pm si es secci\u00f3n AN) Grupo : Cuatro, el cual se dividir\u00e1 en dos subgrupos de dos personas Correcci\u00f3n personal : 21 de noviembre del 2019 despu\u00e9s hora de entrega Este es el proyecto final del curso, por lo que se espera que usted ponga mucho esfuerzo en hacerlo, para demostrar los conocimientos que adquiri\u00f3 durante todo el semestre. El prop\u00f3sito del proyecto es que usted aplique todos los conceptos aprendidos y desarrolle un software completo utilizando como herramienta el lenguaje de programaci\u00f3n Java. Ademas de implementar lo que se le pida, debe cumplir con las siguientes especificaciones para que su proyecto sea considerado como valido: El lenguaje de programaci\u00f3n a utilizar para la implementaci\u00f3n debe ser Java. Por el tipo de proyecto DEBE implementar una interfaz gr\u00e1fica. Para este proyecto se le pide que utilice JFrames, NO APPLETS. Debe utilizar la o las estructuras de datos vistas en clase que mas le ayuden a guardar los datos requeridos. DEBE de utilizar las clases prove\u00eddas por Java para esto. Para la conservaci\u00f3n de los datos ingresados durante la ejecuci\u00f3n del programa, usted tiene que utilizar una base de datos , de tal forma que cuando se vuelva a ejecutar ya utilice datos guardados en ella. Se le explicara mas adelante como la debe utilizar. Su comunicaci\u00f3n debe ser cliente-servidor-cliente , no puede ser solo cliente-cliente . En este proyecto consiste en implementar una aplicaci\u00f3n (cliente-servidor) para un servicio de E-mail. Su proyecto, en general, debe permitir a un usuario, mandar emails a contactos que pertenezcan al mismo servidor, y a contactos en otros servidores. La aplicaci\u00f3n estar\u00e1 dividida en un programa cliente, y un programa servidor, los cuales se comunicaran entre si, utilizando un protocolo de comunicaci\u00f3n definido por nosotros. Dicha comunicaci\u00f3n, solo sera permitida entre cliente y servidor, y/o servidor y servidor.","title":"CC2 - Proyecto Final - Mail Client/Server"},{"location":"#1-programa-cliente","text":"El programa cliente es el encargado de brindar una interfaz al usuario, en la cual pueda hacer las siguientes tareas: Manejo de Contactos: El usuario debe ser capaz de ingresar contactos nuevos (para hacerlo mas simple, solo se guarda el email de el contacto), y ver la lista de contactos que tiene. Lectura de emails: El usuario debe ser capaz de poder leer los emails que le han enviado. Tanto los emails nuevos, como los ya leidos anteriormente. Envi\u00f3 de emails: El usuario debe ser capaz de enviar emails a cualquiera de sus contactos. El email puede tener uno o mas recipientes (to recipients).","title":"1. Programa Cliente"},{"location":"#2-programa-servidor","text":"El programa servidor es el encargado de proveer el servicio de envi\u00f3 de emails, entre usuarios del mismo servidor, y desde/hacia usuarios de otros servidores. Dado que es una aplicaci\u00f3n cliente-servidor, para que un programa cliente envi\u00e9 un email, lo debe hacer a trav\u00e9s de el servidor (solicit\u00e1ndole al servidor que envi\u00e9 el email al respectivo contacto), el cual se comunicara con el programa cliente o servidor respectivo y enviara la informaci\u00f3n. Cada grupo tendr\u00e1 que implementar un programa cliente, y un programa servidor para esta aplicaci\u00f3n. Los grupos se dividir\u00e1n en dos subgrupos, un subgrupo se encargara de hacer el cliente, y otro subgrupo se encargara de hacer el servidor. Uno de los objetivos de el proyecto, es que cualquier cliente perteneciente a cualquier servidor debe poder interactuar (mandar emails) hacia cualquier otro cliente perteneciente a cualquier otro servidor. Para esto, definimos un protocolo de comunicaci\u00f3n, tanto para el programa cliente, como para el programa servidor.","title":"2. Programa Servidor"},{"location":"#3-especificaciones-y-protocolo-de-comunicacion","text":"A continuaci\u00f3n se describe el protocolo completo de comunicaci\u00f3n de un cliente y un servidor. Aseg\u00farese de seguirlo al pie de la letra para que pueda comunicarse sin problema con cualquier otro servidor o cliente. Dentro de la definici\u00f3n de el protocolo, tambi\u00e9n se le dan especificaciones de la funcionalidad que se requiere en el proyecto.","title":"3. Especificaciones y Protocolo de comunicaci\u00f3n"},{"location":"#31-cliente","text":"La comunicaci\u00f3n entre cliente y servidor se har\u00e1 a base de comandos escritos en hileras de caracteres. Dado que su servidor o cliente debe poder comunicarse con el servidor o cliente de otro grupo, deben asegurarse de mandar por la red Strings, y no otro tipo de dato. Los comandos del cliente al servidor son descritos en esta parte. Puede que describamos algunos comandos de respuesta del servidor, asi que este atento a tomar nota.","title":"3.1 CLIENTE"},{"location":"#311-login","text":"La primera tarea que debe dejar hacer el programa cliente a la hora de ejecutarse es permitir al usuario hacer login al servidor. El cliente debe leer del usuario el username, el nombre del servidor al que se va a comunicar y su password (tome en cuenta que el password no puede ser visto por el usuario). El usuario y servidor deben ser ingresados por el usuario de la siguiente manera: 1 usuario@servidor El cliente debe separar este String en dos cosas: el usuario y el nombre del servidor. Despu\u00e9s de verificar que el servidor ingresado este en su tabla de IPs de servidores, el cliente debe abrir una conexi\u00f3n hacia ese servidor especifico y mandarle la primera instrucci\u00f3n que seria la de login: 1 LOGIN username password Al recibir este comando, el servidor debe realizar una serie de operaciones: Primero debe verificar que el usuario (username) se encuentre en su tabla de usuarios. Si no se encuentra, el server debe responder con un error. (lo explicaremos mas tarde) Ya que se verifico que el usuario exista, se compara el password. Si el password es valido entonces se manda al cliente el siguiente acknowledge: 1 OK LOGIN para hacerle ver al cliente que ese usuario existe y que su login esta autorizado, y se marca al usuario como \"Logged In\" Si el password es no valido, el server debe responder con un error (los explicaremos en la parte de errores de el server) Despu\u00e9s de recibir el OK LOGIN del servidor, el cliente debe solicitar la lista de contactos del usuario (la cual esta guardada en el servidor) con la instrucci\u00f3n: 1 CLIST username El server debe responder con una o varias instrucciones, ya que es una lista de uno o varios contactos. Cuando se manda un contact que NO es el ultimo en la lista el server manda una instrucci\u00f3n de la forma : 1 OK CLIST contact@server donde contact es el username del contact, y server el server al que pertenece el contact. Si el contact es el ultimo en la lista, entonces la instrucci\u00f3n seria: 1 OK CLIST contact@server * con el \"*\" el cliente sabr\u00eda que ahi se termino toda la contact list. Luego de obtener el contact list, se deben solicitar los emails nuevos, si hay alguno. Esto se hace con la instrucci\u00f3n: 1 GETNEWMAILS username El server responder\u00e1 a este comando, con la lista de emails nuevos, o una instrucci\u00f3n que indique que no existen emails. Si existen emails, el servidor responder\u00e1 con una instrucci\u00f3n de esta forma: 1 OK GETNEWMAILS sender subject body en donde sender es el email de el contacto o usuario que mando el email, subject es el titulo del email, y body es el cuerpo del email, el texto asociado al email. Dado que pueden haber mas de un nuevo email, para indicar que el email es el ultimo en la lista, se le agrega un \"*\" al final de la instrucci\u00f3n. 1 OK GETNEWMAILS sender subject body * En el caso de que no hayan emails nuevos, el servidor responder\u00e1 con la instrucci\u00f3n: 1 OK GETNEWMAILS NOMAILS Algo importante, es que la fase de login, no es el \u00fanico momento en el que GETNEWMAILS debe ser utilizado. Cada vez que el cliente quiera \"refrescar\" su lista de emails nuevos, debe hacer esta solicitud, el servidor no manda los emails al cliente autom\u00e1ticamente a la hora de recibirlos, es el cliente el que tiene que hacer esto. Ya que el cliente obtuvo el contact list del usuario y sus emails nuevos, se termina el proceso de login del cliente. 1 2 3 4 5 6 7 8 9 10 EJEMPLO DE LOGIN SESSION SIN ERRORES Client : LOGIN andrea password Server : OK LOGIN Client : CLIST andrea Server : OK CLIST contact1@server1 Server : OK CLIST contact2@server2 Server : OK CLIST contact3@server3 * Client : GETNEWMAILS andrea Server : OK GETNEWMAILS xxx@server1 Hola Hola, como estas? Nos vemos pronto Server : OK GETNEWMAILS yyy@server2 Cumple Sofia Hola a todos, el cumple de Sofia va a ser en su casa, el sabado a las 8, los veo ahi. *","title":"3.1.1 Login"},{"location":"#312-envio-de-emails","text":"Para mandar un email a alg\u00fan contacto, el cliente debe mandar la informaci\u00f3n de el email al servidor, el cual despu\u00e9s se encargara de mandarlo al contacto o server indicado. Las instrucciones que debe mandar el cliente al servidor son las siguientes (todas tienen que ir seguidas, sin ninguna otra instrucci\u00f3n en medio): Primero, el cliente debe avisar que a continuaci\u00f3n va a mandar datos de un email, con la siguiente instrucci\u00f3n: 1 SEND MAIL Luego, siguiente a esa instrucci\u00f3n (sin esperar respuesta), se manda el recipient o recipients del email, con las instrucciones: 1 2 MAIL TO contact@server MAIL TO contact@server * el \"*\" indica que ese es el ultimo recipient, o si solo hay uno, ese es el \u00fanico. Despu\u00e9s, deben mandarse las instrucciones de los dem\u00e1s datos de el email (subject y body): 1 2 MAIL SUBJECT text MAIL BODY text y por ultimo, se indica que ya se termino de mandar los datos de el email, con la instrucci\u00f3n: 1 END SEND MAIL a lo que el servidor debe contestar con un: 1 OK SEND MAIL si no hay problemas con los datos. Si en dado caso hay alg\u00fan problema o error, el server responder\u00e1 con un mensaje de error (discutiremos esto en la parte de errores del server).","title":"3.1.2 Envi\u00f3 de Emails"},{"location":"#313-nuevos-contactos","text":"Para agregar un nuevo contacto, el usuario debe ingresar el contacto de la forma contact@server. El cliente antes de poderlo agregar debe verificar su existencia entonces debe mandar la siguiente instrucci\u00f3n al servidor: 1 NEWCONT contact@server el servidor, despu\u00e9s de verificar que SI existe el contacto, responde al cliente con la instrucci\u00f3n: 1 OK NEWCONT contact@server Si en dado caso, el contacto no existe, el server devolver\u00e1 una instrucci\u00f3n de error (se mostraran las instrucciones de error cuando se est\u00e9n describiendo las instrucciones de el server).","title":"3.1.3 Nuevos Contactos"},{"location":"#314-noop-y-logout","text":"Cuando el usuario se va a hacer logout del cliente, el cliente debe mandar un aviso al servidor para que el servidor cierre la sesi\u00f3n con ese cliente, y actualice el estado del usuario a offline: 1 LOGOUT Para que el cliente pueda cerrar la sesi\u00f3n, el servidor debe mandarle un mensaje: 1 OK LOGOUT y recibido este mensaje, el cliente puede cerrar la sesi\u00f3n. Si no lo recibo NO puede cerrar la sesi\u00f3n. El NOOP es un shortcut para NOOPERATION . Esta instrucci\u00f3n sirve para que el servidor sepa que el cliente todav\u00eda esta vivo, es decir que el cliente todav\u00eda esta conectado. Si el servidor no recibe este NOOP cada cierto tiempo (que pasa sin que el cliente haga nada) entonces el servidor cierra la conexi\u00f3n, ya que no esta seguro que el cliente siga vivo. Esto es para evitar que el servidor mantenga conexiones abiertas que no son utilizadas porque el cliente muri\u00f3 (se desconecto). Cuando hablo de que el cliente muri\u00f3 es por ejemplo que la computadora por alguna raz\u00f3n se apago, y no dio tiempo de hacer un LOGOUT formal, entonces el cliente ya no existe, y el servidor tiene abierta esa conexi\u00f3n todav\u00eda, en vano. Entonces, para evitar esto el NOOP se debe mandar cada 20 segundos (20000 milisegundos) despu\u00e9s del ultimo comando. Cada comando que se mande o se reciba (sea cual sea) inicializa el contador del tiempo, y cuando el tiempo llegue a 20000 entonces se manda un noop: 1 NOOP el cual debe seguir con la respuesta del servidor: 1 OK NOOP para que el cliente tambi\u00e9n sepa que el servidor esta vivo.","title":"3.1.4 NOOP y LOGOUT"},{"location":"#32-servidor","text":"Usualmente, el servidor responde a las peticiones del cliente o de otro servidor. En esta parte le explicaremos como debe actuar el servidor con respecto a cada comando recibido ya sea del cliente o de otro servidor.","title":"3.2 SERVIDOR"},{"location":"#321-cliente-servidor","text":"","title":"3.2.1 CLIENTE - SERVIDOR"},{"location":"#3211-login","text":"1 LOGIN username password Este comando es mandado por el cliente para hacer un login de un usuario especifico. Dentro de el servidor existe una tabla de usuarios existentes con su password, y el estado en el que se encuentran (online/offline). Lo primero que debe hacer el servidor es buscar si el usuario existe. Si no existe debe mandar al cliente el comando de error: 1 LOGIN ERROR 101 donde 101 representa al tipo de error \"unknown user\". Si el usuario si existe, entonces compara el password que se guardo en la tabla con el recibido en el comando. Si el password NO es igual entonces el servidor manda al cliente el comando de error: 1 LOGIN ERROR 102 donde 102 representa al tipo de error \"invalid password\". Si el password es correcto, entonces el servidor debe cambiar el estado del usuario a online y mandar al cliente la respuesta: 1 OK LOGIN que significa que el usuario ya esta ingresado como online.","title":"3.2.1.1 Login"},{"location":"#3212-contact-list","text":"1 CLIST username Este es el comando de solicitud de contact list por un cliente. Al recibir el servidor el request de una contact list, debe buscar los contacts asociados con ese usuario y sus estados. Si no hay ningun contact asociado con el usuario el servidor debe mandar un comando de error: 1 CLIST ERROR 103 donde 103 corresponde a \"no contacts found\" . N\u00f3tese que este no es un error como tal, es un warning. Nosotros trabajaremos errores y warnings de igual manera. Si existe alg\u00fan contact entonces el servidor debe mandar los siguientes comandos: 1 2 OK CLIST contact@server o OK CLIST contact@server * donde contact es el username del contacto, y server es el servidor al que pertenece el contact. El \"*\" quiere decir que ese contacto es el ultimo en la lista.","title":"3.2.1.2 Contact List"},{"location":"#3213-send-mail","text":"1 SEND MAIL Esta es el comando que manda el cliente cuando quiere avisarle al servidor que esta por mandar informaci\u00f3n de un email. El servidor debe esperar a recibir el 1 END SEND MAIL para analizar la informaci\u00f3n de email que el cliente mando. Una de las cosas que el servidor debe hacer, es verificar que el o los recipients existan. Si el contacto es de el mismo servidor, esto lo har\u00eda chequeando la tabla de usuarios, si el contacto es de otro servidor, tiene que preguntar a ese servidor si ese contacto existe (esto lo discutiremos en las conversaciones servidor-servidor). Si el contacto no existe, entonces debe mandar al cliente el siguiente error: 1 SEND ERROR 104 contact@server en donde 104 es el error que indica \"unknown contact\" . Si el servidor no existe (o no se encuentra online), entonces se manda al cliente la instrucci\u00f3n: 1 SEND ERROR 105 contact@server en donde 105 indica un error de \"unknown server\" . Ademas de esto, el server debe chequear que los datos que se mandaron est\u00e9n completos, si no es asi, mandar al cliente una de estas tres instrucciones de error: 1 2 3 SEND ERROR 106 SEND ERROR 107 SEND ERROR 108 en donde 106 indica un error de \"no recipient(s)\" , 107 un error de \"no subject\" y 108 un error de \"no body\" .","title":"3.2.1.3 Send Mail"},{"location":"#3214-nuevo-contacto","text":"1 NEWCONT contact@server Este es el comando del cliente que nos indica que su usuario quiere agregar un nuevo contacto. Antes de agregar un nuevo contact el servidor debe asegurarse que el contact realmente exista. Si el contact es local, debe buscarlo en su tabla de usuarios, si no lo encuentra, entonces mandara un mensaje de error: 1 NEWCONT ERROR 109 contact@server que corresponde al tipo de error \"contact not found\". Si el contact no es local, entonces hay que verificar con el servidor correspondiente. Si el server no existe o no esta online, hay que mandar al cliente el mensaje de error: 1 NEWCONT ERROR 110 contact@server que corresponde al tipo de error \"server not found\". Si el contacto existe, entonces se debe mandar un mensaje al cliente : 1 OK NEWCONT contact@server","title":"3.2.1.4 Nuevo Contacto"},{"location":"#3215-noop","text":"1 NOOP NOOP es la instruccion de NO OPERATION solo para que el servidor sepa que el cliente todavia esta vivo. Al recibirla, el servidor debe reiniciar el contador del tiempo del cliente, y mandar una instruccion: 1 OK NOOP para avizarle a el cliente que recibio su mensaje, y para que el sepa que el servidor todavia esta vivo tambien.","title":"3.2.1.5 NOOP"},{"location":"#322-servidor-servidor","text":"El servidor no solo debe comunicarse con los clientes, sino tambi\u00e9n con otros servidores para hacer posible el envi\u00f3 de emails entre usuarios que pertenecen a diferentes servidores. Mas adelante hablaremos de como sabe el server que servidor existen y cuales son sus ips, por el momento supondremos que el servidor ya tiene una tabla con los ips y nombres de los servidores que estan online en este momento. La comunicaci\u00f3n entre servidor y servidor, se reduce a envi\u00f3 de emails y chequeo de contactos existentes.","title":"3.2.2 SERVIDOR - SERVIDOR"},{"location":"#3221-send-mail","text":"1 SEND MAIL contact@server Este comando es enviado de un servidor al otro para indicar que va a mandar informaci\u00f3n acerca de un email que se necesita ser enviado al contacto que se indica en el mismo. Despu\u00e9s a esto, el servidor que mando el comando, debe proseguir a enviar los datos de el email (sin esperar respuesta), de la siguiente forma: 1 2 3 MAIL FROM username@server MAIL SUBJECT text MAIL BODY text y despues concluir con el comando: 1 END SEND MAIL Si no hay problema con el email, entonces el servidor debe contestar con un 1 OK SEND MAIL En el caso de que el contacto no exista, el servidor debe enviar el mensaje de error: 1 SEND ERROR 201 contact@server el cual representa el tipo de error \"unknown contact\". En el caso de otros errores, el servidor debe mandar una de estas posibles instrucciones de error. 1 2 3 SEND ERROR 202 SEND ERROR 203 SEND ERROR 204 En donde 202 es el tipo de error \"no sender (from)\", 203 es \"no subject\" y 204 es \"no body\". El servidor que recibi\u00f3 la notificaci\u00f3n de envi\u00f3 de email, debe guardar el email en la base de datos, el cual sera mandado al usuario en el momento en el que el cliente lo solicite.","title":"3.2.2.1 Send Mail"},{"location":"#3222-check-contact","text":"1 CHECK CONTACT contact@server Si el contacto no existe entonces mandar el warning: 1 CHECK ERROR 205 el cual representa el tipo de error \"unknown contact\" , y si el server que aparece en \"contact@server\" de la instrucci\u00f3n, no es este server, entonces se debe mandar el error: 1 CHECK ERROR 206 el cual representa el tipo de error \"not this server\" .","title":"3.2.2.2 Check Contact"},{"location":"#323-servidor-dns","text":"Para que esta aplicaci\u00f3n funcione correctamente , y los servidores puedan conectarse entre si, va existir un programa (hecho por nosotros, no por ustedes) que va a tener la tarea de un DNS. Este programa llevara el registro de los servidores que est\u00e9n \"online\" y sus ips, para que los servidores puedan solicitarla cuando lo necesiten. Para llevar la tabla actualizada, se necesita que cuando el servidor empiece a ejecutarse, mande un mensaje al programa DNS (cuyo ip debe poderse ingresar en el programa servidor), avis\u00e1ndole que ahora esta en linea, y registrando su ip. La instrucci\u00f3n para esto es: 1 ONLINE servername ip a lo que el DNS le contestara un 1 OK ONLINE servername Si el servidor que manda esta instrucci\u00f3n, ya existe en la tabla de el DNS, entonces se modificara el ip en la tabla (si el ip que se mando en la instrucci\u00f3n, es diferente al que estaba en la tabla). A la hora de que el servidor se \"apague\", debe mandar al DNS la instrucci\u00f3n 1 OFFLINE servername a lo que el DNS contestara 1 OK OFFLINE servername Para obtener el ip-table de los servidores en cualquier momento, el server debe mandar al DNS una solicitud, con la instrucci\u00f3n: 1 GETIPTABLE a lo que el DNS contestara con un listado de servidores con sus ips, utilizando 1 2 OK IPTABLE servername ip o OK IPTABLE servername ip * en donde el \"*\" significa que ese server es el ultimo en la lista/tabla Los errores que manejara(devolver\u00e1) el DNS son: 1 ONLINE ERROR 301 Error que indica un \"ip invalido\". 1 OFFLINE ERROR 302 Error que indica que el servidor que esta haciendo offline, no existe en la tabla (ya sea nunca hizo un online, o ya hab\u00eda hecho offline antes). 1 GETIPTABLE ERROR 303 Que representa un warning de que no hay servidores en la tabla.","title":"3.2.3 SERVIDOR - DNS"},{"location":"#4-otras-indicaciones","text":"","title":"4 Otras Indicaciones"},{"location":"#41-invalid-command","text":"El error que cualquiera de los programas envi\u00e1, si la instrucci\u00f3n que se le envi\u00f3 es invalida, debe ser: 1 INVALID COMMAND ERROR","title":"4.1 Invalid Command"},{"location":"#42-puertos","text":"El servidor debe escuchar en dos puertos diferentes, en el puerto 1400 para los clientes, y en el puerto 1500 para los servidores. El cliente siempre escuchara en el puerto 1400 . El DNS escuchara en el puerto 1200 .","title":"4.2 Puertos"},{"location":"#43-funciones-del-servidor","text":"El servidor tiene como funci\u00f3n principal esperar solicitudes de clientes y servidores. Sin embargo, tambi\u00e9n debe tener funciones para el usuario que lo esta corriendo (server administrator). Una de las funciones que debe permitir el servidor es ingresar el ip de DNS, el cual se mantendr\u00e1 mientras el servidor este ejecut\u00e1ndose. SOLO se pueden agregar usuarios al servidor por medio del mismo servidor, no por medio de clientes, por lo que debe tener esta opci\u00f3n. Tambi\u00e9n debe tener la funci\u00f3n de poder cambiar los puertos en donde se escucha.","title":"4.3 Funciones del Servidor"},{"location":"#44-log-de-comandos","text":"Tanto el servidor como el cliente tiene que escribir los comandos que manda y escucha en la consola.","title":"4.4 Log de Comandos"},{"location":"#45-interfaz-grafica","text":"Tanto el programa cliente, como el programa servidor deben tener interfaz gr\u00e1fica.","title":"4.5 Interfaz Grafica"},{"location":"#46-base-de-datos","text":"Dado que el servidor debe mantener datos como: usuarios, emails, tabla de servidores, etc, usted DEBE de utilizar una base de datos para guardar estos. De tal forma que cuando el servidor se ejecute, lea los datos de dicha base de datos. El cliente deber\u00eda utilizar esta base de datos para guardar los emails (ya leidos de el servidor) por usuarios. La base de datos que usted puede utilizar es SQLite ( http://www.sqlite.org/ ). Para el manejo de la base de datos se le provee la clase DB, la cual puede encontrar en este paquete . Este paquete contiene: La clase DB, en el archivo DB.class El Javadoc para esta clase (API) Una clase y una base de datos prueba. Para poder utilizar la clase, revise el API y la clase de prueba. Si usted desea utilizar otra base de datos, puede hacerlo, utilizando otra librer\u00eda que le ayude a manejar lo puede hacer","title":"4.6 Base de Datos"},{"location":"#5-puntos-extra","text":"Los puntos extra los dejo a su criterio. Nosotros decidiremos si su trabajo extra merece puntos o no, asi que sea creativo.","title":"5. Puntos extra"},{"location":"#6-entrega","text":"Su proyecto es entregado por medio del GES y usted solo debe entregar un archivo llamado pj3-grupoN.zip (donde N es el numero de grupo que se les asigno). Dentro de ese archivo .zip deben ir todos los documentos y archivos que se le piden a continuaci\u00f3n, incluyendo los archivos/documentos extra que usted utilizo para la implementaci\u00f3n de su proyecto. La entrega del proyecto sera personal, el dia que se les indico deben presentarse en la Universidad todos los integrantes del grupo, y traer lo siguiente: Su proyecto, es decir, todos los archivos .java que utilizo en el mismo. Debe venir preparado para mostrar el funcionamiento del mismo en red. (Computadoras, cables de red, etc) Cada uno de los procedimientos y funciones de su c\u00f3digo deben estar debidamente comentariados. Asi como cada clase. (esto no quiere decir que excesivamente comentariadas) Un documento impreso en donde explique como implemento su proyecto, herramientas que utilizo, y todas las estructuras de datos que utilizo, en donde y para que. Un manual de usuario en donde indicara como utilizar su cliente y su servidor.","title":"6. Entrega"},{"location":"#7-grupos","text":"Para recibir numero de grupo debe mandar un email a al correo de su profesor de curso copiando a su auxiliar de clase, indicando los nombres de sus integrantes, de que secci\u00f3n son, e indicando tambi\u00e9n quienes son los encargados del cliente, y quienes del servidor, esto lo debe hacer a m\u00e1s tardar el 25 de octubre del 2019.","title":"7. Grupos"},{"location":"#8-como-empezar","text":"Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin. Si tienen alguna pregunta pueden dir\u00edjanse a Slack y preguntar en los canales correspondientes, solamente si ya han le\u00eddo completamente este documento. Tienen que utilizar git y GitHub para este proyecto, ustedes pueden encontrar un tutorial bastante bueno en el siguiente link . Cada vez que hagan un avance significativo en su proyecto por favor realicen un commit y realicen un push hacia GitHub. Para comenzar con el proyecto, primero tienen que crear su repositorio, esto lo realizan aqu\u00ed . Tienen que trabajar en grupos de 4 personas, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, deben haber enviado un correo a su catedratico con copia a su auxiliar de clase (recuerde incluir en el asunto del correo CC2 y su secci\u00f3n) para que se les asigne un n\u00famero de grupo N el cual les servira para ingresar el nombre grupo con el formato grupo-N , por ejemplo si su n\u00famero de grupo 2B deberia ingresar grupo-2B . En esta ocasi\u00f3n no se les brindan archivos base por lo que el repositorio estara vacio, debe agregar un archivo README.md donde debe colocar los integrantes de su grupo indicando quienes trabajaran en el cliente y quienes trabajaran en el server. Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO y obtendr\u00e1 una nota de 0.","title":"8. \u00bfComo empezar?"}]}